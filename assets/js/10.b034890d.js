(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{365:function(t,s,e){"use strict";e.r(s);var n=e(42),a=Object(n.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"abstractqueuedsynchronizer-aqs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#abstractqueuedsynchronizer-aqs"}},[t._v("#")]),t._v(" AbstractQueuedSynchronizer(AQS)")]),t._v(" "),e("h2",{attrs:{id:"aqs是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aqs是什么"}},[t._v("#")]),t._v(" AQS是什么？")]),t._v(" "),e("blockquote",[e("p",[t._v("字面意思：抽象的队列同步器")]),t._v(" "),e("p",[t._v("技术解释：是用来构建锁或者其他同步器组件的重量级基础框架及整个JUC体系的基石，通过内置\t\t的FIFO队列来完成资源获取线程的排队工作，并通过一个int类型变量表示持有锁的状态")])]),t._v(" "),e("p",[t._v("CLH队列：是一个单向链表，AQS中的队列是CLH变体的虚拟双向队列FIFO")]),t._v(" "),e("h2",{attrs:{id:"aqs为什么是juc内容中最重要的基石"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aqs为什么是juc内容中最重要的基石"}},[t._v("#")]),t._v(" AQS为什么是JUC内容中最重要的基石")]),t._v(" "),e("p",[t._v("锁：面向锁的使用者     定义了程序员和锁交互的使用层API 隐藏了实现细节 你调用即可")]),t._v(" "),e("p",[t._v("同步器：面向锁的实现着    比如java并发大神DougLee，提出统一规范并简化了锁的实现，屏蔽了同    步状态管理、阻塞线程排队和通知、唤醒机制等")]),t._v(" "),e("h2",{attrs:{id:"aqs能干什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aqs能干什么"}},[t._v("#")]),t._v(" AQS能干什么")]),t._v(" "),e("p",[t._v("加锁会导致阻塞：有阻塞就需要排队，实现排队必然需要有某种形式的队列进行管理")]),t._v(" "),e("p",[t._v("解释说明：抢到资源的线程直接使用处理业务逻辑，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等待（类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候），但等候线程仍然保留获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。")]),t._v(" "),e("p",[t._v("既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？")]),t._v(" "),e("p",[t._v("如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁的分配，这个机制主要用的是CLH队列的变体实现，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现，他将请求共享资源的线程封装成队列的节点（Node），通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的效果。")]),t._v(" "),e("h2",{attrs:{id:"aqs初步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aqs初步"}},[t._v("#")]),t._v(" AQS初步")]),t._v(" "),e("p",[t._v("有阻塞就需排队，实现队列必然需要队列")]),t._v(" "),e("blockquote",[e("p",[t._v("AQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个 Node节点来实现锁的分配，通过CAS完成对State值得修改")])]),t._v(" "),e("p",[t._v("AQS的内部架构vuepress/public/aqs.png")]),t._v(" "),e("p",[t._v("AQS的int变量：")]),t._v(" "),e("p",[t._v("​\tAQS的同步状态State成员变量 private volatile int state")]),t._v(" "),e("p",[t._v("​\t银行办理业务的受理窗口状态  0就是没人，自由状态可以办理 大于等于1，有人占用窗口等着")]),t._v(" "),e("p",[t._v("AQS的CLH队列")]),t._v(" "),e("p",[t._v("​\tCLH队列（三个大牛的名字组成），为一个双向队列")]),t._v(" "),e("p",[t._v("​\t银行候客区的等待顾客")]),t._v(" "),e("p",[t._v("总结：")]),t._v(" "),e("p",[t._v("​\t有阻塞就需要排队，实现队列必然需要队列")]),t._v(" "),e("p",[t._v("​\tstate变量+CLH变种的双端队列")]),t._v(" "),e("div",{staticClass:"language-JAVA extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** Marker to indicate a node is waiting in shared mode */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//共享")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" SHARED "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** Marker to indicate a node is waiting in exclusive mode */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//独占")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" EXCLUSIVE "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** waitStatus value to indicate thread has cancelled */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//线程被取消了")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" CANCELLED "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** waitStatus value to indicate successor's thread needs unparking */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//后继线程需要唤醒")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" SIGNAL    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** waitStatus value to indicate thread is waiting on condition */")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//等待condition唤醒")]),t._v("\n   \t\t "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" CONDITION "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n         * waitStatus value to indicate the next acquireShared should\n         * unconditionally propagate\n         */")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 共享式同步状态获取将会无条件地传播下去")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" PROPAGATE "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n         * Status field, taking on only the values:\n         *   SIGNAL:     The successor of this node is (or will soon be)\n         *               blocked (via park), so the current node must\n         *               unpark its successor when it releases or\n         *               cancels. To avoid races, acquire methods must\n         *               first indicate they need a signal,\n         *               then retry the atomic acquire, and then,\n         *               on failure, block.\n         *   CANCELLED:  This node is cancelled due to timeout or interrupt.\n         *               Nodes never leave this state. In particular,\n         *               a thread with cancelled node never again blocks.\n         *   CONDITION:  This node is currently on a condition queue.\n         *               It will not be used as a sync queue node\n         *               until transferred, at which time the status\n         *               will be set to 0. (Use of this value here has\n         *               nothing to do with the other uses of the\n         *               field, but simplifies mechanics.)\n         *   PROPAGATE:  A releaseShared should be propagated to other\n         *               nodes. This is set (for head node only) in\n         *               doReleaseShared to ensure propagation\n         *               continues, even if other operations have\n         *               since intervened.\n         *   0:          None of the above\n         *\n         * The values are arranged numerically to simplify use.\n         * Non-negative values mean that a node doesn't need to\n         * signal. So, most code doesn't need to check for particular\n         * values, just for sign.\n         *\n         * The field is initialized to 0 for normal sync nodes, and\n         * CONDITION for condition nodes.  It is modified using CAS\n         * (or when possible, unconditional volatile writes).\n         */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//初始为0状态是上面的几种 ")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//0 当一个Node被初始化的时候的默认值 ")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//CANCELLED 为1 表示线程获取锁的请求已经取消了")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//condition 为-2 表示节点在等待队列中 节点线程等待唤醒")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//PROPAGATE 为-3 当前线程处在SHARED情况下 该字段才会使用")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" waitStatus"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n         * Link to predecessor node that current node/thread relies on\n         * for checking waitStatus. Assigned during enqueuing, and nulled\n         * out (for sake of GC) only upon dequeuing.  Also, upon\n         * cancellation of a predecessor, we short-circuit while\n         * finding a non-cancelled one, which will always exist\n         * because the head node is never cancelled: A node becomes\n         * head only as a result of successful acquire. A\n         * cancelled thread never succeeds in acquiring, and a thread only\n         * cancels itself, not any other node.\n         */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//前置节点")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" prev"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n         * Link to the successor node that the current node/thread\n         * unparks upon release. Assigned during enqueuing, adjusted\n         * when bypassing cancelled predecessors, and nulled out (for\n         * sake of GC) when dequeued.  The enq operation does not\n         * assign next field of a predecessor until after attachment,\n         * so seeing a null next field does not necessarily mean that\n         * node is at end of queue. However, if a next field appears\n         * to be null, we can scan prev's from the tail to\n         * double-check.  The next field of cancelled nodes is set to\n         * point to the node itself instead of null, to make life\n         * easier for isOnSyncQueue.\n         */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//后继节点")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n         * The thread that enqueued this node.  Initialized on\n         * construction and nulled out after use.\n         */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//包装的线程")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n         * Link to next node waiting on condition, or the special\n         * value SHARED.  Because condition queues are accessed only\n         * when holding in exclusive mode, we just need a simple\n         * linked queue to hold nodes while they are waiting on\n         * conditions. They are then transferred to the queue to\n         * re-acquire. And because conditions can only be exclusive,\n         * we save a field by using special value to indicate shared\n         * mode.\n         */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下一个等待的节点")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" nextWaiter"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n         * Returns true if node is waiting in shared mode.\n         */")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//如果节点在共享模式下等待，则返回true")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("isShared")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" nextWaiter "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" SHARED"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n         * Returns previous node, or throws NullPointerException if null.\n         * Use when predecessor cannot be null.  The null check could\n         * be elided, but is present to help the VM.\n         *\n         * @return the predecessor of this node\n         */")]),t._v("\n    \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//返回上一个节点，如果为null，则抛出NullPointerException 空检查")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("predecessor")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throws")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NullPointerException")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" p "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" prev"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NullPointerException")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n                "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" p"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 空构造")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Used to establish initial head or SHARED marker")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造方法 thread线程 mode")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" mode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("     "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Used by addWaiter")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nextWaiter "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("thread "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" thread"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造方法 thread线程 waitStatus 线程等待状态")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" waitStatus"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Used by Condition")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" waitStatus"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("thread "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" thread"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("AQS同步队列的基本结构\nvuepress/public/AQS同步队列的基本结构.png")]),t._v(" "),e("h2",{attrs:{id:"从我们的reentrantlock开始解读aqs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从我们的reentrantlock开始解读aqs"}},[t._v("#")]),t._v(" 从我们的ReentrantLock开始解读AQS")])])}),[],!1,null,null,null);s.default=a.exports}}]);