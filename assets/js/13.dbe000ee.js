(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{360:function(v,_,t){"use strict";t.r(_);var a=t(42),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[v._v("#")]),v._v(" HashMap")]),v._v(" "),t("blockquote",[t("p",[v._v("什么是Hash：Hash也称散列、哈希、对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值")])]),v._v(" "),t("p",[t("strong",[v._v("Hash的特点：")])]),v._v(" "),t("ol",[t("li",[v._v("从Hash值不可以反向推导出原始的数据")]),v._v(" "),t("li",[v._v("输入数据的微小变化会得到完全不同的Hash值，相同的数据会得到相同的值")]),v._v(" "),t("li",[v._v("哈希算法的执行效率要高效，长的文本也能快速计算出哈希值")]),v._v(" "),t("li",[v._v("hash算法的冲突概率要小")])]),v._v(" "),t("p",[v._v("由于hash的原理是将输入空间的值映射成hash空间内，而hash值得空间远小于输入的空间。根据出题原理，一定会存在不同的输入被映射成相同输出的情况。")]),v._v(" "),t("blockquote",[t("p",[v._v("抽屉原理：桌子上有十个苹果，要把十个苹果放到九个抽屉中，无论怎么放，我们会发现至少会有一个抽屉里面放不少于两个苹果。这一现象就是我们所说的抽屉原理")])]),v._v(" "),t("p",[t("strong",[v._v("一致性Hash：")])]),v._v(" "),t("p",[v._v("​")]),v._v(" "),t("p",[v._v("HashMap的底层结构是 "),t("strong",[v._v("数组+链表+红黑树")])]),v._v(" "),t("p",[v._v("路由寻址公式：（table.length-1）&node.hash")]),v._v(" "),t("p",[v._v("(16-1)&1122 => B0000 0000 1111 & B0100 0110 0010 => B0010 => 2")]),v._v(" "),t("p",[t("strong",[v._v("JDK1.8为什么引入红黑树？")])]),v._v(" "),t("p",[v._v("解决hash碰撞导致链化非常严重，查找效率低下O(1)=>O(N)，提高查找效率")]),v._v(" "),t("p",[v._v("红黑树：自平衡的二叉查找树")]),v._v(" "),t("p",[t("strong",[v._v("HashMap的扩容原理")])]),v._v(" "),t("h2",{attrs:{id:"红黑树的性质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#红黑树的性质"}},[v._v("#")]),v._v(" 红黑树的性质")]),v._v(" "),t("ul",[t("li",[v._v("性质一：每个节点要么是黑色，要么是红色")]),v._v(" "),t("li",[v._v("性质二：根节点是黑色")]),v._v(" "),t("li",[v._v("性质三：每个叶子节点（NIL）是黑色")]),v._v(" "),t("li",[v._v("性质四：每个红色节点的两个子节点一定都是黑色")]),v._v(" "),t("li",[v._v("性质五：任意一节点到每个叶子节点的路径都包含数量相同的黑节点。俗称：黑高")]),v._v(" "),t("li",[v._v("从性植五可以推出：如果一个节点存在黑子节点，那么该节点肯定有两个子节点")])]),v._v(" "),t("blockquote",[t("p",[v._v("红黑树插入后修复红黑树平衡的方法")]),v._v(" "),t("p",[v._v("​\t|---情景1：红黑树为空")]),v._v(" "),t("p",[v._v("​\t|---情景2：插入节点的key已经存在")]),v._v(" "),t("p",[v._v("​\t|---情景3：插入节点的父节点为黑色")]),v._v(" "),t("p",[v._v("​\t|---情景4：插入的节点的父节点为红色**(需要处理的情况)**")]),v._v(" "),t("p",[v._v("​\t\t\t|---情景4.1：叔叔节点存在，并且为红色（父-叔 双红）")]),v._v(" "),t("p",[v._v("​\t\t\t|---情景4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树")]),v._v(" "),t("p",[v._v("​\t\t\t\t|---情景4.2.1：插入节点为其父节点的左子节点（LL情况）")]),v._v(" "),t("p",[v._v("​\t\t\t\t|---情景4.2.2：插入节点为其父节点的右子节点（LR情况）")]),v._v(" "),t("p",[v._v("​\t\t\t|---情景4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树")]),v._v(" "),t("p",[v._v("​\t\t\t\t|---情景4.3.1：插入节点为其父节点的右子节点（RR情况）")]),v._v(" "),t("p",[v._v("​\t\t\t\t|---情景4.2.2：插入节点为其父节点的左子节点（RL情况）")]),v._v(" "),t("p",[v._v("​")])])])}),[],!1,null,null,null);_.default=s.exports}}]);